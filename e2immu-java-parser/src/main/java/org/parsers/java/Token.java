/*
* Generated by: CongoCC Parser Generator. Token.java
*/
package org.parsers.java;

import org.parsers.java.ast.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;


public class Token implements CharSequence, Node.TerminalNode {

    public enum TokenType implements Node.NodeType {
        EOF, CTRL_Z(""), UNDERSCORE("_"), ABSTRACT("abstract"), _ASSERT("assert"),
        BOOLEAN("boolean"), BREAK("break"), BYTE("byte"), CASE("case"), CATCH("catch"),
        CHAR("char"), CLASS("class"), CONST("const"), CONTINUE("continue"), _DEFAULT("default"),
        DO("do"), DOUBLE("double"), ELSE("else"), ENUM("enum"), EXTENDS("extends"),
        FALSE("false"), FINAL("final"), FINALLY("finally"), FLOAT("float"), FOR("for"),
        GOTO("goto"), IF("if"), IMPLEMENTS("implements"), _IMPORT("import"), INSTANCEOF("instanceof"),
        INT("int"), INTERFACE("interface"), LONG("long"), NATIVE("native"), NEW("new"),
        NULL("null"), PACKAGE("package"), PRIVATE("private"), PROTECTED("protected"),
        PUBLIC("public"), RETURN("return"), RECORD("record"), SHORT("short"), STATIC("static"),
        STRICTFP("strictfp"), SUPER("super"), SWITCH("switch"), SYNCHRONIZED("synchronized"),
        THIS("this"), THROW("throw"), THROWS("throws"), TRANSIENT("transient"), TRUE("true"),
        TRY("try"), VAR("var"), VOID("void"), VOLATILE("volatile"), WHILE("while"),
        YIELD("yield"), SEALED("sealed"), NON_SEALED("non-sealed"), PERMITS("permits"),
        WHEN("when"), MODULE("module"), EXPORTS("exports"), OPEN("open"), OPENS("opens"),
        PROVIDES("provides"), REQUIRES("requires"), TO("to"), TRANSITIVE("transitive"),
        USES("uses"), WITH("with"), LPAREN("("), RPAREN(")"), LBRACE("{"), RBRACE("}"),
        LBRACKET("["), RBRACKET("]"), SEMICOLON(";"), COMMA(","), DOT("."), DOUBLE_COLON("::"),
        VAR_ARGS("..."), AT("@"), ASSIGN("="), GT(">"), LT("<"), BANG("!"), TILDE("~"),
        HOOK("?"), COLON(":"), EQ("=="), LE("<="), GE(">="), NE("!="), SC_OR("||"),
        SC_AND("&&"), INCR("++"), DECR("--"), PLUS("+"), MINUS("-"), STAR("*"), SLASH("/"),
        BIT_AND("&"), BIT_OR("|"), XOR("^"), REM("%"), LSHIFT("<<"), PLUSASSIGN("+="),
        MINUSASSIGN("-="), STARASSIGN("*="), SLASHASSIGN("/="), ANDASSIGN("&="), ORASSIGN("|="),
        XORASSIGN("^="), REMASSIGN("%="), LSHIFTASSIGN("<<="), RSIGNEDSHIFT(">>"),
        RUNSIGNEDSHIFT(">>>"), RSIGNEDSHIFTASSIGN(">>="), RUNSIGNEDSHIFTASSIGN(">>>="),
        LAMBDA("->"), WHITESPACE, SINGLE_LINE_COMMENT, MULTI_LINE_COMMENT, CHARACTER_LITERAL,
        STRING_LITERAL, TEXT_BLOCK_LITERAL, INTEGER_LITERAL, LONG_LITERAL, FLOATING_POINT_LITERAL,
        IDENTIFIER, DUMMY, INVALID;

        TokenType() {
        }

        TokenType(String literalString) {
            this.literalString = literalString;
        }

        private String literalString;

        public String getLiteralString() {
            return literalString;
        }

        public boolean isUndefined() {
            return this == DUMMY;
        }

        public boolean isInvalid() {
            return this == INVALID;
        }

        public boolean isEOF() {
            return this == EOF;
        }

    }

    private JavaLexer tokenSource;
    private TokenType type = TokenType.DUMMY;
    private int beginOffset;
    private int endOffset;
    private boolean unparsed;
    private Node parent;

    public void truncate(int amount) {
        int newEndOffset = Math.max(getBeginOffset(), getEndOffset() - amount);
        setEndOffset(newEndOffset);
    }

    /**
    * It would be extremely rare that an application
    * programmer would use this method. It needs to
    * be public because it is part of the org.parsers.java.Node interface.
    */
    public void setBeginOffset(int beginOffset) {
        this.beginOffset = beginOffset;
    }

    /**
    * It would be extremely rare that an application
    * programmer would use this method. It needs to
    * be public because it is part of the org.parsers.java.Node interface.
    */
    public void setEndOffset(int endOffset) {
        this.endOffset = endOffset;
    }

    /**
    * @return the JavaLexer object that handles
    * location info for the tokens.
    */
    public JavaLexer getTokenSource() {
        return this.tokenSource;
    }

    /**
    * It should be exceedingly rare that an application
    * programmer needs to use this method.
    */
    public void setTokenSource(TokenSource tokenSource) {
        this.tokenSource = (JavaLexer) tokenSource;
    }

    public boolean isInvalid() {
        return getType().isInvalid();
    }

    /**
    * Return the TokenType of this Token object
    */
    @Override
    public TokenType getType() {
        return type;
    }

    protected void setType(TokenType type) {
        this.type = type;
    }

    /**
    * @return whether this Token represent actual input or was it inserted somehow?
    */
    public boolean isVirtual() {
        return type == TokenType.EOF;
    }

    /**
    * @return Did we skip this token in parsing?
    */
    public boolean isSkipped() {
        return false;
    }

    public int getBeginOffset() {
        return beginOffset;
    }

    public int getEndOffset() {
        return endOffset;
    }

    /**
    * @return the string image of the token.
    */
    @Override
    /**
    * @return the next _cached_ regular (i.e. parsed) token
    * or null
    */
    public final Token getNext() {
        return getNextParsedToken();
    }

    /**
    * @return the previous regular (i.e. parsed) token
    * or null
    */
    public final Token getPrevious() {
        Token result = previousCachedToken();
        while (result != null && result.isUnparsed()) {
            result = result.previousCachedToken();
        }
        return result;
    }

    /**
    * @return the next regular (i.e. parsed) token
    */
    private Token getNextParsedToken() {
        Token result = nextCachedToken();
        while (result != null && result.isUnparsed()) {
            result = result.nextCachedToken();
        }
        return result;
    }

    /**
    * @return the next token of any sort (parsed or unparsed or invalid)
    */
    public Token nextCachedToken() {
        if (getType() == TokenType.EOF) return null;
        JavaLexer tokenSource = getTokenSource();
        return tokenSource != null ? (Token) tokenSource.nextCachedToken(getEndOffset()) : null;
    }

    public Token previousCachedToken() {
        if (getTokenSource() == null) return null;
        return (Token) getTokenSource().previousCachedToken(getBeginOffset());
    }

    Token getPreviousToken() {
        return previousCachedToken();
    }

    public Token replaceType(TokenType type) {
        Token result = newToken(type, getTokenSource(), getBeginOffset(), getEndOffset());
        getTokenSource().cacheToken(result);
        return result;
    }

    public String getSource() {
        if (type == TokenType.EOF) return "";
        JavaLexer ts = getTokenSource();
        int beginOffset = getBeginOffset();
        int endOffset = getEndOffset();
        return ts == null || beginOffset <= 0 && endOffset <= 0 ? null : ts.getText(beginOffset, endOffset);
    }

    protected Token() {
    }

    public Token(TokenType type, JavaLexer tokenSource, int beginOffset, int endOffset) {
        this.type = type;
        this.tokenSource = tokenSource;
        this.beginOffset = beginOffset;
        this.endOffset = endOffset;
    }

    public boolean isUnparsed() {
        return unparsed;
    }

    public void setUnparsed(boolean unparsed) {
        this.unparsed = unparsed;
    }

    /**
    * @return An iterator of the tokens preceding this one.
    */
    public Iterator<Token> precedingTokens() {
        return new Iterator<Token>() {
            Token currentPoint = Token.this;

            public boolean hasNext() {
                return currentPoint.previousCachedToken() != null;
            }

            public Token next() {
                Token previous = currentPoint.previousCachedToken();
                if (previous == null) throw new java.util.NoSuchElementException("No previous token!");
                return currentPoint = previous;
            }

        };
    }

    /**
    * @return a list of the unparsed tokens preceding this one in the order they appear in the input
    */
    public List<Token> precedingUnparsedTokens() {
        List<Token> result = new ArrayList<>();
        Token t = this.previousCachedToken();
        while (t != null && t.isUnparsed()) {
            result.add(t);
            t = t.previousCachedToken();
        }
        Collections.reverse(result);
        return result;
    }

    /**
    * @return An iterator of the (cached) tokens that follow this one.
    */
    public Iterator<Token> followingTokens() {
        return new java.util.Iterator<Token>() {
            Token currentPoint = Token.this;

            public boolean hasNext() {
                return currentPoint.nextCachedToken() != null;
            }

            public Token next() {
                Token next = currentPoint.nextCachedToken();
                if (next == null) throw new java.util.NoSuchElementException("No next token!");
                return currentPoint = next;
            }

        };
    }

    public void copyLocationInfo(Token from) {
        setTokenSource(from.getTokenSource());
        setBeginOffset(from.getBeginOffset());
        setEndOffset(from.getEndOffset());
    }

    public void copyLocationInfo(Token start, Token end) {
        setTokenSource(start.getTokenSource());
        if (tokenSource == null) setTokenSource(end.getTokenSource());
        setBeginOffset(start.getBeginOffset());
        setEndOffset(end.getEndOffset());
    }

    public static Token newToken(TokenType type, JavaLexer tokenSource) {
        Token result = newToken(type, tokenSource, 0, 0);
        return result;
    }

    public static Token newToken(TokenType type, String image, JavaLexer tokenSource) {
        Token newToken = newToken(type, tokenSource);
        return newToken;
    }

    public static Token newToken(TokenType type, JavaLexer tokenSource, int beginOffset, int endOffset) {
        switch(type) {
            case TRANSITIVE : 
                return new KeyWord(TokenType.TRANSITIVE, tokenSource, beginOffset, endOffset);
            case UNDERSCORE : 
                return new KeyWord(TokenType.UNDERSCORE, tokenSource, beginOffset, endOffset);
            case HOOK : 
                return new Operator(TokenType.HOOK, tokenSource, beginOffset, endOffset);
            case VAR : 
                return new KeyWord(TokenType.VAR, tokenSource, beginOffset, endOffset);
            case THROW : 
                return new KeyWord(TokenType.THROW, tokenSource, beginOffset, endOffset);
            case INTEGER_LITERAL : 
                return new IntegerLiteral(TokenType.INTEGER_LITERAL, tokenSource, beginOffset, endOffset);
            case STATIC : 
                return new KeyWord(TokenType.STATIC, tokenSource, beginOffset, endOffset);
            case MINUS : 
                return new Operator(TokenType.MINUS, tokenSource, beginOffset, endOffset);
            case WHEN : 
                return new KeyWord(TokenType.WHEN, tokenSource, beginOffset, endOffset);
            case STARASSIGN : 
                return new Operator(TokenType.STARASSIGN, tokenSource, beginOffset, endOffset);
            case INTERFACE : 
                return new KeyWord(TokenType.INTERFACE, tokenSource, beginOffset, endOffset);
            case SEMICOLON : 
                return new Delimiter(TokenType.SEMICOLON, tokenSource, beginOffset, endOffset);
            case WHITESPACE : 
                return new Whitespace(TokenType.WHITESPACE, tokenSource, beginOffset, endOffset);
            case BREAK : 
                return new KeyWord(TokenType.BREAK, tokenSource, beginOffset, endOffset);
            case BYTE : 
                return new Primitive(TokenType.BYTE, tokenSource, beginOffset, endOffset);
            case ELSE : 
                return new KeyWord(TokenType.ELSE, tokenSource, beginOffset, endOffset);
            case IF : 
                return new KeyWord(TokenType.IF, tokenSource, beginOffset, endOffset);
            case ENUM : 
                return new KeyWord(TokenType.ENUM, tokenSource, beginOffset, endOffset);
            case BANG : 
                return new Operator(TokenType.BANG, tokenSource, beginOffset, endOffset);
            case LPAREN : 
                return new Delimiter(TokenType.LPAREN, tokenSource, beginOffset, endOffset);
            case DOT : 
                return new Delimiter(TokenType.DOT, tokenSource, beginOffset, endOffset);
            case LONG_LITERAL : 
                return new LongLiteral(TokenType.LONG_LITERAL, tokenSource, beginOffset, endOffset);
            case CASE : 
                return new KeyWord(TokenType.CASE, tokenSource, beginOffset, endOffset);
            case AT : 
                return new Delimiter(TokenType.AT, tokenSource, beginOffset, endOffset);
            case SLASHASSIGN : 
                return new Operator(TokenType.SLASHASSIGN, tokenSource, beginOffset, endOffset);
            case SC_AND : 
                return new Operator(TokenType.SC_AND, tokenSource, beginOffset, endOffset);
            case OPENS : 
                return new KeyWord(TokenType.OPENS, tokenSource, beginOffset, endOffset);
            case PUBLIC : 
                return new KeyWord(TokenType.PUBLIC, tokenSource, beginOffset, endOffset);
            case THROWS : 
                return new KeyWord(TokenType.THROWS, tokenSource, beginOffset, endOffset);
            case NON_SEALED : 
                return new KeyWord(TokenType.NON_SEALED, tokenSource, beginOffset, endOffset);
            case XOR : 
                return new Operator(TokenType.XOR, tokenSource, beginOffset, endOffset);
            case PROVIDES : 
                return new KeyWord(TokenType.PROVIDES, tokenSource, beginOffset, endOffset);
            case LBRACE : 
                return new Delimiter(TokenType.LBRACE, tokenSource, beginOffset, endOffset);
            case GOTO : 
                return new KeyWord(TokenType.GOTO, tokenSource, beginOffset, endOffset);
            case RSIGNEDSHIFTASSIGN : 
                return new Operator(TokenType.RSIGNEDSHIFTASSIGN, tokenSource, beginOffset, endOffset);
            case CHAR : 
                return new Primitive(TokenType.CHAR, tokenSource, beginOffset, endOffset);
            case ASSIGN : 
                return new Operator(TokenType.ASSIGN, tokenSource, beginOffset, endOffset);
            case ORASSIGN : 
                return new Operator(TokenType.ORASSIGN, tokenSource, beginOffset, endOffset);
            case CATCH : 
                return new KeyWord(TokenType.CATCH, tokenSource, beginOffset, endOffset);
            case PLUSASSIGN : 
                return new Operator(TokenType.PLUSASSIGN, tokenSource, beginOffset, endOffset);
            case DOUBLE : 
                return new Primitive(TokenType.DOUBLE, tokenSource, beginOffset, endOffset);
            case PROTECTED : 
                return new KeyWord(TokenType.PROTECTED, tokenSource, beginOffset, endOffset);
            case LONG : 
                return new Primitive(TokenType.LONG, tokenSource, beginOffset, endOffset);
            case RUNSIGNEDSHIFT : 
                return new Operator(TokenType.RUNSIGNEDSHIFT, tokenSource, beginOffset, endOffset);
            case COMMA : 
                return new Delimiter(TokenType.COMMA, tokenSource, beginOffset, endOffset);
            case MULTI_LINE_COMMENT : 
                return new MultiLineComment(TokenType.MULTI_LINE_COMMENT, tokenSource, beginOffset, endOffset);
            case YIELD : 
                return new KeyWord(TokenType.YIELD, tokenSource, beginOffset, endOffset);
            case FLOATING_POINT_LITERAL : 
                return new FloatingPointLiteral(TokenType.FLOATING_POINT_LITERAL, tokenSource, beginOffset, endOffset);
            case LBRACKET : 
                return new Delimiter(TokenType.LBRACKET, tokenSource, beginOffset, endOffset);
            case RSIGNEDSHIFT : 
                return new Operator(TokenType.RSIGNEDSHIFT, tokenSource, beginOffset, endOffset);
            case PRIVATE : 
                return new KeyWord(TokenType.PRIVATE, tokenSource, beginOffset, endOffset);
            case OPEN : 
                return new KeyWord(TokenType.OPEN, tokenSource, beginOffset, endOffset);
            case CONTINUE : 
                return new KeyWord(TokenType.CONTINUE, tokenSource, beginOffset, endOffset);
            case VAR_ARGS : 
                return new Delimiter(TokenType.VAR_ARGS, tokenSource, beginOffset, endOffset);
            case STAR : 
                return new Operator(TokenType.STAR, tokenSource, beginOffset, endOffset);
            case _ASSERT : 
                return new KeyWord(TokenType._ASSERT, tokenSource, beginOffset, endOffset);
            case INCR : 
                return new Operator(TokenType.INCR, tokenSource, beginOffset, endOffset);
            case LE : 
                return new Operator(TokenType.LE, tokenSource, beginOffset, endOffset);
            case TO : 
                return new KeyWord(TokenType.TO, tokenSource, beginOffset, endOffset);
            case REM : 
                return new Operator(TokenType.REM, tokenSource, beginOffset, endOffset);
            case VOLATILE : 
                return new KeyWord(TokenType.VOLATILE, tokenSource, beginOffset, endOffset);
            case EXTENDS : 
                return new KeyWord(TokenType.EXTENDS, tokenSource, beginOffset, endOffset);
            case INSTANCEOF : 
                return new KeyWord(TokenType.INSTANCEOF, tokenSource, beginOffset, endOffset);
            case NEW : 
                return new KeyWord(TokenType.NEW, tokenSource, beginOffset, endOffset);
            case SC_OR : 
                return new Operator(TokenType.SC_OR, tokenSource, beginOffset, endOffset);
            case RECORD : 
                return new KeyWord(TokenType.RECORD, tokenSource, beginOffset, endOffset);
            case LT : 
                return new Operator(TokenType.LT, tokenSource, beginOffset, endOffset);
            case CLASS : 
                return new KeyWord(TokenType.CLASS, tokenSource, beginOffset, endOffset);
            case DO : 
                return new KeyWord(TokenType.DO, tokenSource, beginOffset, endOffset);
            case FINALLY : 
                return new KeyWord(TokenType.FINALLY, tokenSource, beginOffset, endOffset);
            case _DEFAULT : 
                return new KeyWord(TokenType._DEFAULT, tokenSource, beginOffset, endOffset);
            case XORASSIGN : 
                return new Operator(TokenType.XORASSIGN, tokenSource, beginOffset, endOffset);
            case CONST : 
                return new KeyWord(TokenType.CONST, tokenSource, beginOffset, endOffset);
            case PACKAGE : 
                return new KeyWord(TokenType.PACKAGE, tokenSource, beginOffset, endOffset);
            case REMASSIGN : 
                return new Operator(TokenType.REMASSIGN, tokenSource, beginOffset, endOffset);
            case REQUIRES : 
                return new KeyWord(TokenType.REQUIRES, tokenSource, beginOffset, endOffset);
            case TRY : 
                return new KeyWord(TokenType.TRY, tokenSource, beginOffset, endOffset);
            case TEXT_BLOCK_LITERAL : 
                return new StringLiteral(TokenType.TEXT_BLOCK_LITERAL, tokenSource, beginOffset, endOffset);
            case CTRL_Z : 
                return new CTRL_Z(TokenType.CTRL_Z, tokenSource, beginOffset, endOffset);
            case MINUSASSIGN : 
                return new Operator(TokenType.MINUSASSIGN, tokenSource, beginOffset, endOffset);
            case _IMPORT : 
                return new KeyWord(TokenType._IMPORT, tokenSource, beginOffset, endOffset);
            case SYNCHRONIZED : 
                return new KeyWord(TokenType.SYNCHRONIZED, tokenSource, beginOffset, endOffset);
            case ANDASSIGN : 
                return new Operator(TokenType.ANDASSIGN, tokenSource, beginOffset, endOffset);
            case RUNSIGNEDSHIFTASSIGN : 
                return new Operator(TokenType.RUNSIGNEDSHIFTASSIGN, tokenSource, beginOffset, endOffset);
            case NULL : 
                return new NullLiteral(TokenType.NULL, tokenSource, beginOffset, endOffset);
            case CHARACTER_LITERAL : 
                return new CharacterLiteral(TokenType.CHARACTER_LITERAL, tokenSource, beginOffset, endOffset);
            case FOR : 
                return new KeyWord(TokenType.FOR, tokenSource, beginOffset, endOffset);
            case TRUE : 
                return new BooleanLiteral(TokenType.TRUE, tokenSource, beginOffset, endOffset);
            case FINAL : 
                return new KeyWord(TokenType.FINAL, tokenSource, beginOffset, endOffset);
            case RPAREN : 
                return new Delimiter(TokenType.RPAREN, tokenSource, beginOffset, endOffset);
            case EQ : 
                return new Operator(TokenType.EQ, tokenSource, beginOffset, endOffset);
            case BOOLEAN : 
                return new Primitive(TokenType.BOOLEAN, tokenSource, beginOffset, endOffset);
            case DECR : 
                return new Operator(TokenType.DECR, tokenSource, beginOffset, endOffset);
            case LAMBDA : 
                return new Operator(TokenType.LAMBDA, tokenSource, beginOffset, endOffset);
            case MODULE : 
                return new KeyWord(TokenType.MODULE, tokenSource, beginOffset, endOffset);
            case RBRACE : 
                return new Delimiter(TokenType.RBRACE, tokenSource, beginOffset, endOffset);
            case NE : 
                return new Operator(TokenType.NE, tokenSource, beginOffset, endOffset);
            case THIS : 
                return new ThisLiteral(TokenType.THIS, tokenSource, beginOffset, endOffset);
            case BIT_OR : 
                return new Operator(TokenType.BIT_OR, tokenSource, beginOffset, endOffset);
            case SWITCH : 
                return new KeyWord(TokenType.SWITCH, tokenSource, beginOffset, endOffset);
            case VOID : 
                return new KeyWord(TokenType.VOID, tokenSource, beginOffset, endOffset);
            case TRANSIENT : 
                return new KeyWord(TokenType.TRANSIENT, tokenSource, beginOffset, endOffset);
            case PLUS : 
                return new Operator(TokenType.PLUS, tokenSource, beginOffset, endOffset);
            case PERMITS : 
                return new KeyWord(TokenType.PERMITS, tokenSource, beginOffset, endOffset);
            case FLOAT : 
                return new Primitive(TokenType.FLOAT, tokenSource, beginOffset, endOffset);
            case NATIVE : 
                return new KeyWord(TokenType.NATIVE, tokenSource, beginOffset, endOffset);
            case LSHIFTASSIGN : 
                return new Operator(TokenType.LSHIFTASSIGN, tokenSource, beginOffset, endOffset);
            case ABSTRACT : 
                return new KeyWord(TokenType.ABSTRACT, tokenSource, beginOffset, endOffset);
            case STRICTFP : 
                return new KeyWord(TokenType.STRICTFP, tokenSource, beginOffset, endOffset);
            case INT : 
                return new Primitive(TokenType.INT, tokenSource, beginOffset, endOffset);
            case RETURN : 
                return new KeyWord(TokenType.RETURN, tokenSource, beginOffset, endOffset);
            case SEALED : 
                return new KeyWord(TokenType.SEALED, tokenSource, beginOffset, endOffset);
            case SINGLE_LINE_COMMENT : 
                return new SingleLineComment(TokenType.SINGLE_LINE_COMMENT, tokenSource, beginOffset, endOffset);
            case EXPORTS : 
                return new KeyWord(TokenType.EXPORTS, tokenSource, beginOffset, endOffset);
            case IDENTIFIER : 
                return new Identifier(TokenType.IDENTIFIER, tokenSource, beginOffset, endOffset);
            case BIT_AND : 
                return new Operator(TokenType.BIT_AND, tokenSource, beginOffset, endOffset);
            case GE : 
                return new Operator(TokenType.GE, tokenSource, beginOffset, endOffset);
            case SUPER : 
                return new KeyWord(TokenType.SUPER, tokenSource, beginOffset, endOffset);
            case SLASH : 
                return new Operator(TokenType.SLASH, tokenSource, beginOffset, endOffset);
            case IMPLEMENTS : 
                return new KeyWord(TokenType.IMPLEMENTS, tokenSource, beginOffset, endOffset);
            case RBRACKET : 
                return new Delimiter(TokenType.RBRACKET, tokenSource, beginOffset, endOffset);
            case COLON : 
                return new Operator(TokenType.COLON, tokenSource, beginOffset, endOffset);
            case USES : 
                return new KeyWord(TokenType.USES, tokenSource, beginOffset, endOffset);
            case GT : 
                return new Operator(TokenType.GT, tokenSource, beginOffset, endOffset);
            case WITH : 
                return new KeyWord(TokenType.WITH, tokenSource, beginOffset, endOffset);
            case SHORT : 
                return new Primitive(TokenType.SHORT, tokenSource, beginOffset, endOffset);
            case DOUBLE_COLON : 
                return new Delimiter(TokenType.DOUBLE_COLON, tokenSource, beginOffset, endOffset);
            case LSHIFT : 
                return new Operator(TokenType.LSHIFT, tokenSource, beginOffset, endOffset);
            case FALSE : 
                return new BooleanLiteral(TokenType.FALSE, tokenSource, beginOffset, endOffset);
            case WHILE : 
                return new KeyWord(TokenType.WHILE, tokenSource, beginOffset, endOffset);
            case TILDE : 
                return new Operator(TokenType.TILDE, tokenSource, beginOffset, endOffset);
            case STRING_LITERAL : 
                return new StringLiteral(TokenType.STRING_LITERAL, tokenSource, beginOffset, endOffset);
            case INVALID : 
                return new InvalidToken(tokenSource, beginOffset, endOffset);
            default : 
                return new Token(type, tokenSource, beginOffset, endOffset);
        }
    }

    public String getLocation() {
        return getInputSource() + ":" + getBeginLine() + ":" + getBeginColumn();
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent = parent;
    }

    public boolean isEmpty() {
        return length() == 0;
    }

    public int length() {
        return endOffset - beginOffset;
    }

    public CharSequence subSequence(int start, int end) {
        return getTokenSource().subSequence(beginOffset + start, beginOffset + end);
    }

    public char charAt(int offset) {
        return getTokenSource().charAt(beginOffset + offset);
    }

    /**
    * @deprecated Use toString() instead
    */
    @Deprecated
    public String getImage() {
        return toString();
    }

    @Override
    public String toString() {
        String result = getSource();
        if (result == null) {
            result = getType().getLiteralString();
        }
        return result;
    }

}


