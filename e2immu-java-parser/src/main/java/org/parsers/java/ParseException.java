/* Generated by: CongoCC Parser Generator. ParseException.java  */
package org.parsers.java;

import java.util.*;


public class ParseException extends RuntimeException {
    // The token we tripped up on.
    private Node.TerminalNode token;
    //We were expecting one of these token types
    private Set<? extends Node.NodeType> expectedTypes;
    private List<NonTerminalCall> callStack = new ArrayList<>();

    public ParseException(Node.TerminalNode token, Set<? extends Node.NodeType> expectedTypes, List<NonTerminalCall> callStack) {
        this.token = token;
        this.expectedTypes = expectedTypes;
        if (callStack != null) {
            this.callStack = new ArrayList<>(callStack);
        }
    }

    public ParseException(Node.TerminalNode token) {
        this.token = token;
    }

    public ParseException(String message) {
        super(message);
    }

    public ParseException() {
        super();
    }

    public ParseException(String message, List<NonTerminalCall> callStack) {
        super(message);
        if (callStack != null) {
            this.callStack = new ArrayList<>(callStack);
        }
    }

    public ParseException(String message, Node.TerminalNode token, List<NonTerminalCall> callStack) {
        super(message);
        this.token = token;
        if (callStack != null) {
            this.callStack = new ArrayList<>(callStack);
        }
    }

    public boolean hitEOF() {
        return token != null && token.getType().isEOF();
    }

    @Override
    public String getMessage() {
        StringBuilder buf = new StringBuilder();
        buf.append(super.getMessage());
        if (token == null && expectedTypes == null) {
            buf.append(getCustomStackTrace());
            return buf.toString();
        }
        String location = token != null ? token.getLocation() : "";
        buf.append("\nEncountered an error");
        if (token != null) {
            buf.append(" at (or somewhere around) " + token.getLocation());
            if (hitEOF()) {
                buf.append("\nUnexpected end of input.");
                buf.append(getCustomStackTrace());
                return buf.toString();
            }
        }
        if (expectedTypes == null || token == null || expectedTypes.contains(token.getType())) {
            buf.append(getCustomStackTrace());
            return buf.toString();
        }
        String content = token.toString();
        if (content == null || content.length() == 0) {
            buf.append("\n Found token of type " + token.getType());
        } else {
            if (content.length() > 32) content = content.substring(0, 32) + "...";
            buf.append("\nFound string \"" + addEscapes(content) + "\" of type " + token.getType());
        }
        if (expectedTypes.size() == 1) {
            buf.append("\nWas expecting: " + expectedTypes.iterator().next());
        } else {
            buf.append("\nWas expecting one of the following:\n");
            boolean isFirst = true;
            for (Node.NodeType type : expectedTypes) {
                if (!isFirst) buf.append(", ");
                isFirst = false;
                buf.append(type);
            }
        }
        buf.append(getCustomStackTrace());
        return buf.toString();
    }

    public String getCustomStackTrace() {
        StringBuilder buf = new StringBuilder();
        buf.append("\n----------\n");
        for (int i = callStack.size() - 1; i >= 0; i--) {
            buf.append("        ");
            buf.append(callStack.get(i));
        }
        buf.append("----------");
        return buf.toString();
    }

    /**
    * Returns the token which causes the parse error and null otherwise.
    * @return the token which causes the parse error and null otherwise.
    */
    public Node.TerminalNode getToken() {
        return token;
    }

    private static String addEscapes(String str) {
        StringBuilder retval = new StringBuilder();
        for (int ch : str.codePoints().toArray()) {
            switch(ch) {
                case '\b' : 
                    retval.append("\\b");
                    continue;
                case '\t' : 
                    retval.append("\\t");
                    continue;
                case '\n' : 
                    retval.append("\\n");
                    continue;
                case '\f' : 
                    retval.append("\\f");
                    continue;
                case '\r' : 
                    retval.append("\\r");
                    continue;
                case '\"' : 
                    retval.append("\\\"");
                    continue;
                case '\'' : 
                    retval.append("\\\'");
                    continue;
                case '\\' : 
                    retval.append("\\\\");
                    continue;
                default : 
                    if (Character.isISOControl(ch)) {
                        String s = "0000" + java.lang.Integer.toString(ch, 16);
                        retval.append("\\u" + s.substring(s.length() - 4));
                    } else {
                        retval.appendCodePoint(ch);
                    }
                    continue;
            }
        }
        return retval.toString();
    }

}


